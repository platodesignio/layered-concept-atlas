generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Enums ────────────────────────────────────────────────────────────────────

enum Role {
  VIEWER
  MEMBER
  EDITOR
  PROJECT_OWNER
  NETWORK_ADMIN
}

enum Visibility {
  PROJECT_ONLY
  NETWORK_ONLY
  LINK_ONLY
  PUBLIC
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
  CANCELLED
}

enum TimelineEventKind {
  PROJECT_CREATED
  PROJECT_UPDATED
  STPF_NODE_CREATED
  STPF_NODE_UPDATED
  REPORT_PUBLISHED
  VOTE_CAST
  SUPPORT_ONCHAIN
  SUPPORT_STRIPE
  FRIEND_ACCEPTED
  FOLLOW_ADDED
  COMMENT_ADDED
  REPORT_REVISED
}

enum TimelineVisibility {
  PUBLIC
  NETWORK_ONLY
  FRIENDS_ONLY
  PRIVATE
}

enum ReportStatus {
  DRAFT
  PENDING_APPROVAL
  PUBLISHED
  REJECTED
}

enum SiweStatus {
  PENDING
  VERIFIED
  EXPIRED
  USED
}

enum FlagTargetType {
  PROJECT
  REPORT
  COMMENT
  USER
  EXTERNAL_LINK
  DM_MESSAGE
}

enum FlagStatus {
  OPEN
  REVIEWING
  RESOLVED
  DISMISSED
}

enum SupportKind {
  STRIPE_MEMBERSHIP
  ONCHAIN_ETH
}

enum StpfType {
  STRUCTURE_ANALYSIS
  THEORY_NODE
  PAPER
  FIELD_IMPLEMENTATION
}

// ─── User & Auth ──────────────────────────────────────────────────────────────

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  emailVerified   DateTime?
  name            String?
  displayName     String?
  bio             String?
  role            Role      @default(MEMBER)
  isFrozen        Boolean   @default(false)
  frozenAt        DateTime?
  frozenReason    String?
  walletAddress   String?   @unique
  avatarUrl       String?
  // Privacy settings
  friendListPublic    Boolean @default(false)
  timelineVisibility  TimelineVisibility @default(FRIENDS_ONLY)
  dmFromFriendsOnly   Boolean @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  accounts        Account[]
  sessions        Session[]
  auditLogs       AuditLog[]          @relation("UserAuditLogs")
  projects        Project[]           @relation("ProjectOwner")
  memberships     ProjectMember[]
  stpfNodes       StpfNode[]
  reports         Report[]
  reportVersions  ReportVersion[]
  votes           Vote[]
  supports        Support[]
  sentRequests    FriendRequest[]     @relation("SentRequests")
  receivedRequests FriendRequest[]    @relation("ReceivedRequests")
  friendshipsA    Friendship[]        @relation("FriendA")
  friendshipsB    Friendship[]        @relation("FriendB")
  blocksInitiated Block[]             @relation("BlockerUser")
  blocksReceived  Block[]             @relation("BlockedUser")
  conversations   ConversationParticipant[]
  messages        Message[]
  timelineEvents  TimelineEvent[]
  follows         Follow[]
  feedbacks       Feedback[]
  flags           Flag[]
  comments        Comment[]
  notifications   Notification[]
  walletConnections WalletConnection[]
  siweNonces      SiweNonce[]
  stripeCustomer  StripeCustomer?
  networkMembership NetworkMembership?
  supporterBadges SupporterBadge[]

  @@index([email])
  @@index([walletAddress])
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ─── SIWE ────────────────────────────────────────────────────────────────────

model SiweNonce {
  id        String     @id @default(cuid())
  nonce     String     @unique
  userId    String?
  status    SiweStatus @default(PENDING)
  expiresAt DateTime
  createdAt DateTime   @default(now())
  usedAt    DateTime?
  purpose   String     @default("wallet_connect")
  targetId  String?

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([nonce])
  @@index([expiresAt])
  @@map("siwe_nonces")
}

// ─── Wallet ───────────────────────────────────────────────────────────────────

model WalletConnection {
  id            String   @id @default(cuid())
  userId        String
  address       String
  chainId       Int
  verifiedAt    DateTime @default(now())
  lastSignedAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, address])
  @@index([userId])
  @@map("wallet_connections")
}

// ─── Project ─────────────────────────────────────────────────────────────────

model Project {
  id              String     @id @default(cuid())
  slug            String     @unique
  title           String
  description     String
  tags            String[]
  visibility      Visibility @default(NETWORK_ONLY)
  isFrozen        Boolean    @default(false)
  frozenAt        DateTime?
  frozenReason    String?
  ownerId         String
  receiptAddress  String?    // ETH wallet for onchain donations
  searchVector    Unsupported("tsvector")?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  owner           User             @relation("ProjectOwner", fields: [ownerId], references: [id])
  members         ProjectMember[]
  stpfNodes       StpfNode[]
  reports         Report[]
  votes           Vote[]
  supports        Support[]
  flags           Flag[]
  timelineEvents  TimelineEvent[]
  follows         Follow[]
  comments        Comment[]
  auditLogs       AuditLog[]       @relation("ProjectAuditLogs")
  supporterBadges SupporterBadge[]

  @@index([ownerId])
  @@index([visibility])
  @@map("projects")
}

model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  role      Role     @default(MEMBER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@map("project_members")
}

// ─── STPF Nodes ──────────────────────────────────────────────────────────────

model StpfNode {
  id          String   @id @default(cuid())
  projectId   String
  type        StpfType
  title       String
  content     Json     // type-specific fields stored as JSON
  authorId    String
  searchVector Unsupported("tsvector")?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  author      User       @relation(fields: [authorId], references: [id])
  linksFrom   StpfLink[] @relation("LinkFrom")
  linksTo     StpfLink[] @relation("LinkTo")
  reportItems ReportStpfItem[]

  @@index([projectId])
  @@index([type])
  @@map("stpf_nodes")
}

model StpfLink {
  id          String   @id @default(cuid())
  fromNodeId  String
  toNodeId    String
  linkType    String   // derived_from | validates | implements | observes
  description String?
  createdAt   DateTime @default(now())

  fromNode StpfNode @relation("LinkFrom", fields: [fromNodeId], references: [id], onDelete: Cascade)
  toNode   StpfNode @relation("LinkTo",   fields: [toNodeId],   references: [id], onDelete: Cascade)

  @@unique([fromNodeId, toNodeId, linkType])
  @@map("stpf_links")
}

// ─── Reports ─────────────────────────────────────────────────────────────────

model Report {
  id              String       @id @default(cuid())
  projectId       String
  authorId        String
  approverId      String?
  status          ReportStatus @default(DRAFT)
  visibility      Visibility   @default(PROJECT_ONLY)
  periodFrom      DateTime
  periodTo        DateTime
  outcomes        String
  progress        String
  issues          String
  risks           String
  nextActions     String
  supportNeeds    Json         // { type: string, description: string }[]
  externalLinks   String[]
  collaborators   String[]
  revisionReason  String?
  publishedAt     DateTime?
  rejectedAt      DateTime?
  rejectedReason  String?
  parentReportId  String?      // for revised versions
  versionNumber   Int          @default(1)
  searchVector    Unsupported("tsvector")?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  project       Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)
  author        User           @relation(fields: [authorId], references: [id])
  stpfItems     ReportStpfItem[]
  versions      ReportVersion[]
  flags         Flag[]
  comments      Comment[]
  timelineEvents TimelineEvent[]

  @@index([projectId])
  @@index([authorId])
  @@index([status])
  @@map("reports")
}

model ReportVersion {
  id             String       @id @default(cuid())
  reportId       String
  versionNumber  Int
  snapshotJson   Json
  revisionReason String
  createdById    String
  createdAt      DateTime     @default(now())

  report     Report @relation(fields: [reportId], references: [id], onDelete: Cascade)
  createdBy  User   @relation(fields: [createdById], references: [id])

  @@index([reportId])
  @@map("report_versions")
}

model ReportStpfItem {
  id         String   @id @default(cuid())
  reportId   String
  stpfNodeId String
  action     String   // what was done to/with this node in this report period
  createdAt  DateTime @default(now())

  report    Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  stpfNode  StpfNode @relation(fields: [stpfNodeId], references: [id], onDelete: Cascade)

  @@unique([reportId, stpfNodeId])
  @@map("report_stpf_items")
}

// ─── Comments ─────────────────────────────────────────────────────────────────

model Comment {
  id         String     @id @default(cuid())
  authorId   String
  projectId  String?
  reportId   String?
  content    String
  isDeleted  Boolean    @default(false)
  deletedAt  DateTime?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  author  User     @relation(fields: [authorId], references: [id])
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  report  Report?  @relation(fields: [reportId], references: [id], onDelete: Cascade)
  flags   Flag[]

  @@index([projectId])
  @@index([reportId])
  @@map("comments")
}

// ─── Votes ────────────────────────────────────────────────────────────────────

model Vote {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  value     Int      @default(1) // always 1; unique constraint prevents double
  createdAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@map("votes")
}

// ─── Support ──────────────────────────────────────────────────────────────────

model Support {
  id          String      @id @default(cuid())
  projectId   String
  userId      String
  kind        SupportKind
  amountWei   String?     // for onchain
  txHash      String?     // for onchain
  chainId     Int?        // for onchain
  stripePaymentIntentId String? // for stripe
  confirmedAt DateTime?
  createdAt   DateTime    @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge   SupporterBadge?

  @@index([projectId])
  @@index([userId])
  @@map("supports")
}

model SupporterBadge {
  id        String   @id @default(cuid())
  supportId String   @unique
  userId    String
  projectId String
  issuedAt  DateTime @default(now())

  support Support @relation(fields: [supportId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("supporter_badges")
}

// ─── Stripe ───────────────────────────────────────────────────────────────────

model StripeCustomer {
  id               String   @id @default(cuid())
  userId           String   @unique
  stripeCustomerId String   @unique
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  memberships  NetworkMembership[]

  @@map("stripe_customers")
}

model NetworkMembership {
  id                   String   @id @default(cuid())
  userId               String   @unique
  stripeSubscriptionId String   @unique
  stripePriceId        String
  stripeCustomerId     String
  status               String   // active | past_due | canceled | incomplete
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripeCustomer StripeCustomer @relation(fields: [stripeCustomerId], references: [stripeCustomerId])

  @@map("network_memberships")
}

model BillingEvent {
  id            String    @id @default(cuid())
  stripeEventId String    @unique
  type          String
  payloadJson   Json
  receivedAt    DateTime  @default(now())
  processedAt   DateTime?
  processResult String?

  @@map("billing_events")
}

// ─── Friends ──────────────────────────────────────────────────────────────────

model FriendRequest {
  id          String              @id @default(cuid())
  senderId    String
  receiverId  String
  message     String?
  status      FriendRequestStatus @default(PENDING)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  sender   User @relation("SentRequests",     fields: [senderId],   references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([receiverId])
  @@map("friend_requests")
}

model Friendship {
  id        String   @id @default(cuid())
  userAId   String
  userBId   String
  createdAt DateTime @default(now())

  userA User @relation("FriendA", fields: [userAId], references: [id], onDelete: Cascade)
  userB User @relation("FriendB", fields: [userBId], references: [id], onDelete: Cascade)

  @@unique([userAId, userBId])
  @@map("friendships")
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker User @relation("BlockerUser", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("BlockedUser", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("blocks")
}

// ─── DM ───────────────────────────────────────────────────────────────────────

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants ConversationParticipant[]
  messages     Message[]

  @@map("conversations")
}

model ConversationParticipant {
  id             String    @id @default(cuid())
  conversationId String
  userId         String
  lastReadAt     DateTime?
  createdAt      DateTime  @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             String    @id @default(cuid())
  conversationId String
  senderId       String
  encryptedBody  String    // AES-256-GCM encrypted body; iv prepended as hex:ciphertext
  isDeleted      Boolean   @default(false)
  deletedAt      DateTime?
  deleteReason   String?
  createdAt      DateTime  @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id])
  flags        Flag[]

  @@index([conversationId])
  @@index([senderId])
  @@map("messages")
}

// ─── Timeline ─────────────────────────────────────────────────────────────────

model TimelineEvent {
  id          String             @id @default(cuid())
  kind        TimelineEventKind
  actorId     String
  projectId   String?
  reportId    String?
  stpfNodeId  String?
  targetUserId String?
  metadata    Json?
  visibility  TimelineVisibility @default(FRIENDS_ONLY)
  createdAt   DateTime           @default(now())

  actor   User     @relation(fields: [actorId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  report  Report?  @relation(fields: [reportId], references: [id], onDelete: SetNull)

  @@index([actorId, createdAt])
  @@index([projectId, createdAt])
  @@index([visibility, createdAt])
  @@map("timeline_events")
}

// ─── Follow ───────────────────────────────────────────────────────────────────

model Follow {
  id        String   @id @default(cuid())
  userId    String
  projectId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([userId, projectId])
  @@index([projectId])
  @@map("follows")
}

// ─── Audit Log ───────────────────────────────────────────────────────────────

model AuditLog {
  id         String   @id @default(cuid())
  userId     String?
  action     String
  entityType String
  entityId   String
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  user    User?    @relation("UserAuditLogs", fields: [userId], references: [id], onDelete: SetNull)
  project Project? @relation("ProjectAuditLogs", fields: [entityId], references: [id], onDelete: NoAction, map: "audit_project_fk")

  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

// ─── Flag / Report ────────────────────────────────────────────────────────────

model Flag {
  id           String         @id @default(cuid())
  reporterId   String
  targetType   FlagTargetType
  projectId    String?
  reportId     String?
  commentId    String?
  messageId    String?
  targetUserId String?
  reason       String
  details      String?
  desiredAction String?
  status       FlagStatus     @default(OPEN)
  adminNotes   String?
  resolvedAt   DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  reporter User     @relation(fields: [reporterId], references: [id])
  project  Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  report   Report?  @relation(fields: [reportId], references: [id], onDelete: Cascade)
  comment  Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  message  Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([targetType])
  @@map("flags")
}

// ─── Feedback ─────────────────────────────────────────────────────────────────

model Feedback {
  id           String   @id @default(cuid())
  executionId  String
  userId       String?
  rating       Int      // 1-5
  comment      String?
  pagePath     String?
  url          String?
  userAgent    String?
  context      Json?    // { operationHistory, targetObjectId, walletConnected }
  status       String   @default("open") // open | reviewing | resolved
  adminNotes   String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([executionId])
  @@index([status])
  @@map("feedbacks")
}

// ─── Notification ─────────────────────────────────────────────────────────────

model Notification {
  id        String   @id @default(cuid())
  userId    String
  kind      String
  title     String
  body      String
  linkUrl   String?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@map("notifications")
}

// ─── Rate Limit ───────────────────────────────────────────────────────────────

model RateLimit {
  id        String   @id @default(cuid())
  key       String   // ip:endpoint or userId:endpoint
  count     Int      @default(1)
  windowEnd DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([key])
  @@index([windowEnd])
  @@map("rate_limits")
}

// ─── Export Log ───────────────────────────────────────────────────────────────

model ExportLog {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  format    String   // json | pdf
  sha256    String?
  createdAt DateTime @default(now())

  @@index([projectId])
  @@map("export_logs")
}
